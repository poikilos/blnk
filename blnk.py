#!/usr/bin/env python
import sys
import os
import platform
import subprocess

blnkTemplate = '''Content-Type: text/blnk
Encoding:UTF-8
Type:{Type}
NoDisplay:true
Terminal:{Terminal}
Name:{Name}
Comment:Open the file/directory (This was generated by blnk -s {Exec}).
Exec:{Exec}
'''

__doc__ = '''
Blnk (pronounced "blink") makes or runs a shortcut to a file or
directory.

The blnk format is (based on the XDG .desktop file format):
{Template}


If you run such a file and blnk runs it in a text editor, the problem
is that the first line must be the Content-Type line shown (It is case
sensitive), and there must not be any blank line before it.


Options:
-s                Create a shortcut to the given file.
--terminal        Specify "Terminal=true" in the blnk file to indicate
                    that the "Exec" file should run in a Terminal.

The following examples assume you've already made a symlink to blnk.py
as ~/.local/bin/blnk (and that ~/.local/bin is in your path--otherwise,
make the symlink as /usr/local/bin/blnk instead. On windows, make a
batch file that runs blnk and sends the parameters to it).

Create a shortcut:
blnk -s %SOME_PATH%

Where %SOME_PATH% is a full path to a blnk file without the
symbols. The new .blnk file will appear in the current working directory
and the name will be the same as the given filename but with the
extension changed to ".blnk".


Run a shortcut:
blnk %SOME_BLNK_FILE%

Where %SOME_BLNK_FILE% is a full path to a blnk file without the
symbols.

'''.format(Template=blnkTemplate)


# - Type is "Directory" or "File"
# - Name may be shown in the OS but usually isn't (from XDG .desktop
#   format).
# - Exec is the path to actually run (a directory or file). Environment
#   variables are allowed (with the symbols shown):
#   - %USERPROFILES%

class FileTypeError(Exception):
    pass

profile = None

myDirName = "blnk"
AppDatas = None
local = None
myLocal = None
shortcutsDir = None
if platform.system() == "Windows":
    profile = os.environ.get("USERPROFILE")
    tmp = os.path.join(profile, "AppData")
    AppDatas = os.path.join(tmp, "Roaming")
    local = os.path.join(tmp, "Local")
    share = local
    myShare = os.path.join(local, myDirName)
    shortcutsDir = os.path.join(profile, "Desktop")
    dtPath = os.path.join(shortcutsDir, "blnk.blnk")
else:
    profile = os.environ.get("HOME")
    AppDatas = os.path.join(profile, ".config")
    local = os.path.join(profile, ".local")
    share = os.path.join(local, "share")
    myShare = os.path.join(share, "blnk")
    shortcutsDir = os.path.join(share, "applications")
    dtPath = os.path.join(shortcutsDir, "blnk.desktop")

myBinPath = __file__
tryBinPath = os.path.join(local, "bin", "blnk")
if os.path.isfile(tryBinPath):
    myBinPath = tryBinPath

class BLink:
    NO_SECTION = "\n"

    def __init__(self, path, assignmentOperator=":",
                 commentDelimiter="#"):
        self.contentType = None
        self.tree = {}
        self.lastSection = None
        self.path = None
        self.assignmentOperator = assignmentOperator
        self.commentDelimiter = commentDelimiter
        try:
            self.load(path)
        except FileTypeError as ex:
            raise ex

    def splitLine(self, line):
        i = line.find(self.assignmentOperator)
        if i < 0:
            raise ValueError("The line contains no '{}': `{}`"
                             "".format(self.assignmentOperator,
                                       line))
        ls = line.strip()
        if self.isComment(ls):
            raise ValueError("splitLine doesn't work on comments.")
        if self.isSection(ls):
            raise ValueError("splitLine doesn't work on sections.")
        k = line[:i].strip()
        v = line[i+len(self.assignmentOperator):].strip()
        if self.commentDelimiter in v:
            print("WARNING: `{}` contains a comment delimiter '{}'"
                  " but inline comments are not supported."
                  "".format(line, self.commentDelimiter))
        return (k, v)

    def getSection(self, line):
        ls = line.strip()
        if ((len(ls) >= 2) and ls.startswith('[') and ls.endswith(']')):
            return ls[1:-1].strip()
        return None

    def isSection(self, line):
        return self.getSection(line) is not None

    def isComment(self, line):
        return line.strip().startswith(self.commentDelimiter)

    def _pushLine(self, line, row=None, col=None):
        '''
        Keyword arguments
        row -- Show this row (such as line_index+1) in syntax messages.
        col -- Show this col (such as char_index+1) in syntax messages.
        '''
        if row is None:
            if self.lastSection is not None:
                print("WARNING: The line `{}` was a custom line not on"
                      " a row of a file, but it will be placed in the"
                      " \"{}\" section which was still present."
                      "".format(line, self.lastSection))
        if self.contentType is None:
            if not line.startswith("Content-Type:"):
                raise FileTypeError(
                    "The file must contain \"Content-Type:\""
                    " (usually \"Content-Type: text/blnk\")"
                    " before anything else, but"
                    " _pushLine got \"{}\" (last file: {})"
                    "".format(line, self.path)
                )
                print("* running file directly...")
        trySection = self.getSection(line)
        if self.isComment(line):
            pass
        elif trySection is not None:
            section = trySection
            if len(section) < 1:
                pre = ""
                if lineN is not None:
                    if self.path is not None:
                        pre = self.path + ":"
                        if row is not None:
                            pre += str(row) + ":"
                            if col is not None:
                                pre += str(col) + ":"
                if len(pre) > 0:
                    pre += " "
                raise ValueError(pre+"_pushLine got an empty section")
            else:
                self.lastSection = section
        else:
            k, v = self.splitLine(line)
            if k == "Content-Type":
                self.contentType = v
                return
            section = self.lastSection
            if section is None:
                section = BLink.NO_SECTION
            sectionD = self.tree.get(section)
            if sectionD is None:
                sectionD = {}
                self.tree[section] = sectionD
            sectionD[k] = v

    def load(self, path):
        self.path = path
        with open(path, 'r') as ins:
            row = 0
            for line in ins:
                row += 1
                try:
                    self._pushLine(line, row=row)
                except FileTypeError as ex:
                    print(str(ex))
                    print("* running file directly...")
                    self._choose_app(self.path)
                    raise ex
            self.lastSection = None

    def getBranch(self, section, key):
        '''
        Get a tuple containing the section (section name key for
        self.tree) and the value self.tree[section][key]. The reason
        section is returned is in case the key doesn't exist there but
        exists in another section.
        '''
        v = None
        sectionD = self.tree.get(section)
        if sectionD is not None:
            v = sectionD.get(key)
        if v is None:
            section = None
            for trySection, sectionD in self.tree.keys():
                v = sectionD.get(key)
                if v is not None:
                    section = trySection
                    break
        return section, v

    def getExec(self):
        result = None
        trySection = BLink.NO_SECTION
        key = "Exec"
        section, v = self.getBranch(trySection, key)
        if v is None:
            path = self.path
            if path is not None:
                path = "\"" + path + "\""
            print("WARNING: There was no \"{}\" variable in {}"
                  "".format(key, path))
            return None
        elif section != trySection:
            sectionMsg = section
            if section == BLink.NO_SECTION:
                sectionMsg = "the main section"
            else:
                sectionMsg = "[{}]".format(section)
            print("WARNING: \"{}\" was in {}".format(key, sectionMsg))
        if v is None:
            return None
        path = v
        if v[1:2] == ":":
            if v[2:3] != "\\":
                raise ValueError(
                    "The third character should be '\\' when the"
                    " 2nd character is ':', but the Exec value was"
                    " \"{}\"".format(v)
                )
            if platform.system() != "Windows":
                path = v[3:].replace("\\", "/")
                if "%USERPROFILE%" in path:
                    path = path.replace("%USERPROFILE%", profile)
                else:
                    if path.lower().startswith("users/"):
                        parts = path.split("/")
                        # print("parts={}".format(parts))
                        rel = os.path.join(*parts[2:])
                        old = os.path.join(*parts[:2])
                        print("* changing \"{}\" to \"{}\""
                              "".format(old, profile))
                        # ^ splat ('*') since join takes multiple
                        #   params not a list.
                        foundCloud = "owncloud/"
                        cloud = os.path.join(profile, "Nextcloud")
                        # cloud = os.path.join(profile, "ownCloud")
                        if (rel.lower().startswith(foundCloud)
                                and os.path.isdir(cloud)):
                            path = os.path.join(
                                cloud,
                                rel[len(foundCloud):],
                            )
                            print("* changed \"{}\" to \"{}\""
                                  "".format(os.path.join(*parts[:2]),
                                            cloud))
                        else:
                            path = os.path.join(profile, rel)

        return path

    @staticmethod
    def _run_parts(parts, check=True):
        print("* running \"{}\"...".format(parts))
        runner = subprocess.check_call
        if hasattr(subprocess, 'run'):
            runner = subprocess.check_call
            print("  - using subprocess.check_call")
        try:
            runner(parts, check=check)
        except TypeError as ex:
            if "unexpected keyword argument 'check'" in str(ex):
                runner(parts)
            else:
                raise ex

    @staticmethod
    def _run(path):
        tryCmd = "xdg-open"
        # TODO: try os.popen('open "{}"') on mac
        if platform.system() == "Windows":
            os.startfile(path, 'open')
            # runner('cmd /c start "{}"'.format(path))
            return
        try:
            print("  - {}...".format(tryCmd))
            BLink._run_parts([tryCmd, path], check=True)
        except OSError as ex:
            try:
                print("  - open...")
                BLink._run_parts(['open', path], check=True)
            except OSError as ex:
                print("  - trying xdg-launch...")
                BLink._run_parts(['xdg-launch', path], check=True)

    def _choose_app(self, path):
        print("  - choosing app for \"{}\"".format(path))
        app = "geany"
        print("    - {}".format(app))
        BLink._run_parts([app, self.path])

    def run(self):
        execStr = self.getExec()
        if execStr is None:
            print("* Exec is None...")
            self._choose_app(execStr)
            return
        BLink._run(execStr)

dtLines = [
    "[Desktop Entry]",
    "Exec={}".format(myBinPath),
    "MimeType=text/blnk;",
    "Name=blnk".format(myBinPath),
    "NoDisplay=true",
    "Type=Application",
]

def usage():
    print(__doc__)

def main(args):
    print("* checking for \"{}\"".format(dtPath))
    if not os.path.isfile(dtPath):
        print("* writing \"{}\"...".format(dtPath))
        with open(dtPath, 'w') as outs:
            for line in dtLines:
                outs.write(line + "\n")
        if not platform.system == "Windows":
            print("  - installing...")
            iconCommandParts = ["xdg-desktop-icon", "install",
                                "--novendor"]
            cmdParts = iconCommandParts + [dtPath]
            try:
                BLink._run_parts(cmdParts)
            except subprocess.CalledProcessError:
                os.remove(dtPath)
                # ^ so it will try again next time
                print("{} failed.".format(cmdParts))
                print(str(cmdParts))

    if len(args) < 2:
        usage()
        raise ValueError("Error: The first argument is the program but"
                         " there is no argument after that. Provide a"
                         " file path.")
    MODE_RUN = "run"
    MODE_CS = "create shortcut"
    mode = MODE_RUN
    path = None
    Terminal = "false"
    for i in range(1, len(args)):
        arg = args[i]
        if arg == "-s":
            mode = MODE_CS
        elif arg == "--terminal":
            Terminal = "true"
        else:
            if path is None:
                path = arg
            else:
                raise ValueError("The option \"{}\" is unknown and the"
                                 " path was already \"{}\""
                                 "".format(arg, path))
    if path is None:
        usage()
        print("Error: The path was not set (args={}).".format(args))
        exit(1)
    Type = None
    if os.path.isdir(path):
        Type = "Directory"
    elif os.path.isfile(path):
        Type = "File"
    if Type is None:
        usage()
        print("Error: The path \"{}\" is not a file or directory"
              " (args={}).".format(path, args))
        exit(1)

    if mode == MODE_RUN:
        try:
            link = BLink(path)
            link.run()
        except FileTypeError:
            pass
            # already handled by Blink
    elif mode == MODE_CS:
        Name = os.path.splitext(os.path.split(path)[-1])[0]
        newName = Name + ".blnk"
        newPath = newName
        # ^ Use the current directory, so do not use the full path.
        content = blnkTemplate.format(Type=Type, Name=Name, Exec=path,
                                      Terminal=Terminal)
        # print(content)
        if os.path.exists(newPath):
            print("Error: {} already exists.".format(newPath))
            exit(1)
        with open(newPath, 'w') as outs:
            outs.write(content)
        print("* wrote \"{}\"".format(newPath))
    else:
        raise NotImplementedError("The mode \"{}\" is not known."
                                  "".format(mode))

if __name__ == "__main__":
    main(sys.argv)
